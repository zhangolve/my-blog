
# 数据结构

- 顺序结构  常见的是数组
- 非顺序结构  常见的是链表

*  存储密度的概念

> 在数据结构中，存储密度：结点数据本身所占的存储量和整个结点结构所占的存储量之比。存储密度 = （结点数据本身所占的存储量）/（结点结构所占的存储总量）

>举例
typedef struct node{
char data[16]；
struct node *next;
} LinkStrNode　以上定义了一个数据结点，这个结点包括两个部分，数据部分：data[16],这是一个字符数组，占16个字节，　非数据部分：*next ,是一个结点指针，设占4个字节，
则以上的存储密度为16/(16+4)=80%


引出了散列的概念。在计算机中，假设要从10万个词汇中搜索一个特定的词汇，比如「张三」，那么应该采取怎样的搜索算法呢。这里也就用到了散列。

>将要检索的项与用来检索的索引（称为散列，或者散列值）关联起来，生成一种便于搜索的数据结构（称为散列表）。也译为散列。旧译哈希（误以为是人名而采用了音译）。它也常用作一种资讯安全的实作方法，由一串资料中经过散列算法（Hashing algorithms）计算出来的资料指纹（data fingerprint），经常用来识别档案与资料是否有被窜改，以保证档案与资料确实是由原创者所提供。
如今，散列算法也被用来加密存在数据库中的密码（password）字串，由于散列算法所计算出来的散列值（Hash Value）具有不可逆（无法逆向演算回原本的数值）的性质，因此可有效的保护密码。

以上解释来自维基百科，所以说散列算法其实就是哈希算法。哈希算法用来进行数据的加密解密，我们常常看到的md5等就是哈希算法。关于哈希算法，我在[CS50](http://hktkdy.com/2016/07/10/201607/CS50-note/)的笔记中也有提到。


至于构造散列表和散列表的应用，应该也会在接下来的课程中提到。


# ADT（抽象数据类型）

抽象类型数据类型关注的是算法本身，而不关心具体的实现。这让我想到其实有点像是哲学的意思，哲学不就是有点大而论道。

抽象数据类型的几个点

- 取值空间
- 访问空间
- 命名空间



接着就是讲了一些抽象数据类型的具体事例，比如向量容器等。不过向量容器在c++中应用多一些。



# 时间复杂度

O()

关于时间复杂度，我在[CS50](http://hktkdy.com/2016/07/10/201607/CS50-note/)的笔记中也有提到，这里还是要强调的死，冒泡排序算法时间复杂度O(N^2)，而快速排序时间复杂度为O(Nlog(n))

在这里老师也提到了一个衡量一个程序好坏的直观判断，cpu占用率和内存占用。当然抽象的，就是时间复杂度了。

这也让我想到，我自己的最近写的项目中，由于不合理地javascript代码造成的单页面高内存占用。理由是由于监听dom中body的变动，而他一直在变动，导致内存占用变大，乃至卡死。

关于算法的分析，还可以从最坏，最好，平均这几个点来考虑。这一点，cs50也有提到，还是拿冒泡算法最容易理解了。


在本课中，也提到了两个经典的问题

* 八皇后问题

>八皇后问题是一个以国际象棋为背景的问题：如何能够在8×8的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后？为了达到此目的，任两个皇后都不能处于同一条横行、纵行或斜线上。八皇后问题可以推广为更一般的n皇后摆放问题：这时棋盘的大小变为n×n，而皇后个数也变成n。当且仅当n = 1或n ≥ 4时问题有解[1]。

* 汉诺塔

> 汉诺塔（港台：河内塔）是根据一个传说形成的数学问题：
有三根杆子A，B，C。A杆上有N个(N>1)穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至C杆：
每次只能移动一个圆盘；
大盘不能叠在小盘上面。
提示：可将圆盘临时置于B杆，也可将从A杆移出的圆盘重新移回A杆，但都必须遵循上述两条规则。
问：如何移？最少要移动多少次？

